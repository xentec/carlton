#ifndef BOT_INC
#define BOT_INC

#include "astar.nxc"
#include "log.nxc"
#include "map.nxc"
#include "table.nxc"
#include "vector.nxc"

#include "motor.nxc"

#define BOT_SIMULATE 0

#define BOT_START_DIR vecDOWN

#define BOT_RPM 40
#define BOT_MIN_POWER 40
#define BOT_CORR_POWER 30

#define BOT_WHEEL_DIA 43.2 // (mm)
#define BOT_MOTOR_TOLERANCE 2 // (mm)



struct PathEntry
{
	unsigned int hash;
	Vector path[];
};

struct Bot
{
	Vector pos;
	Vector dir;
	int dirDegree;

	Vector begin;
	PathEntry savedPaths[];

	Motor motorA;
	Motor motorC;
};

void botInit(Bot& bot)
{
	bot.dir = BOT_START_DIR;
	bot.dirDegree = vecAngle(vecRIGHT, bot.dir);
	bot.pos = vecNULL;

	bot.motorA.port = OUT_A;
	bot.motorC.port = OUT_C;
}

void botStart(Bot& bot)
{
	bot.pos = bot.begin;
}


void botSavePath(Bot& bot, const Vector& begin, const Vector& end, const Vector& path[])
{
	int len = ArrayLen(bot.savedPaths);
	if(!len) {
		int tableNum = TABLE_NUM*TABLE_NUM;
		ArrayInit(bot.savedPaths, 0, tableNum);
	}

	PathEntry peNew;
	peNew.hash = vecHash(vecSub(end, begin));
	peNew.path = path;

	int idx = peNew.hash % len;
	bool saved = false;
	PathEntry pe;

	for(int i = idx; i < len-idx; i++)
	{
		pe = bot.savedPaths[i];

		if(pe.hash == peNew.hash)
			return;

		if(!pe.hash) {
			bot.savedPaths[i] = peNew;
			saved = true;
			break;
		}
	}
	if(!saved)
		bot.savedPaths[idx] = peNew;
}

bool botHasPath(const Bot& bot, const Vector& begin, const Vector& end, Vector& path[])
{
	int len = ArrayLen(bot.savedPaths);
	if(!len)
		return false;

	unsigned int hash = vecHash(vecSub(end, begin));
 //	unsigned int hashRev = vecHash(vecSub(begin, end));

	PathEntry pe;
	int idx = hash % len;

	for(int i = idx; i < len-idx; i++)
	{
		pe = bot.savedPaths[i];
		if(pe.hash == hash) {
			path = pe.path;
			return true;
		}
 /*		
		if(pe.hash == hashRev) {
			path = pe.path;
			pathReverse(path);
			return true;
		}
 */
	}
	return false;
}



// TODO: actual moving
void botMove(Bot& bot, const Vector& way, byte power)
{
	Vector goal = vecAdd(bot.pos, way);
	int distance = MAP_CELL_CM * abs(vecLength(way));


	logDebug( StrCat("DR:", vecToString(bot.pos), "+",vecToString(way), "=", vecToString(goal)) );

#if BOT_SIMULATE	
	while(!vecEq(bot.pos, goal))
	{
		Wait(1000/power);
		vecAddIp(bot.pos, bot.dir);
		logDebug(StrCat(">",vecToString(bot.pos)));
	}
#else
	vecAddIp(bot.pos, way);
	Drive(distance, power);
#endif

}

void botRotate(Bot& bot, const Vector& dir, byte power) 
{
	int degree = vecAngle(bot.dir, dir);
	int inc = sign(degree);
	int goalDegree = (bot.dirDegree + degree);

	logDebug( StrCat("RT:", vecToString(bot.dir), "->", vecToString(dir)) );
	logDebug( StrCat("  :", NumToStr(bot.dirDegree), "+ ", NumToStr(degree), "=", NumToStr(goalDegree)));

#if BOT_SIMULATE
	while(bot.dirDegree != goalDegree)
	{
		Wait(1000/power); 

		bot.dirDegree += inc;
		if(bot.dirDegree % 10 == 0 || bot.dirDegree == degree)
			logDebug(StrCat(">", NumToStr(bot.dirDegree)));
	}
#else
	bot.dirDegree += degree;
	Rotate(degree, power);
#endif

	bot.dirDegree %= 360;
	bot.dir = dir;
}
// ################

void botRun(Bot& bot, const Vector& path[])
{
	Vector rel, norm;
	int len = ArrayLen(path);

	int i;
	for(i = 0; i < len-1; i++) 
	{
		logDebug( StrCat("MV:", vecToString(bot.pos),"->", vecToString(path[i])) );

		rel = vecSub(path[i], bot.pos);
		norm = vecNorm(rel);

		logDebug( StrCat("REL:", vecToString(rel)," NRM:", vecToString(norm)) );

		if(!vecEq(bot.dir, norm)) 
			botRotate(bot, norm, BOT_MIN_POWER);

		botMove(bot, rel, BOT_MIN_POWER);
	}

	rel = vecSub(path[i], bot.pos);
	norm = vecNorm(rel);
	if(!vecEq(bot.dir, norm)) 
		botRotate(bot, norm, BOT_MIN_POWER);

	if(!vecEq(path[i], bot.begin))
		return;

	botMove(bot, rel, BOT_MIN_POWER);
}

#endif // BOT_INC