#ifndef BOT_INC
#define BOT_INC

#include "astar.nxc"
#include "log.nxc"
#include "table.nxc"
#include "vector.nxc"

#define BOT_START_DIR vecUP


struct PathEntry
{
	unsigned int hash;
	Vector path[];
};

struct Bot
{
	Vector pos;
	Vector dir;
	int dirDegree;

	Vector begin;
	PathEntry savedPaths[];
};

void botInit(Bot& bot)
{
	bot.dir = BOT_START_DIR;
	bot.dirDegree = vecAngle(vecLEFT, bot.dir);
	bot.pos = vecNULL;
}

void botStart(Bot& bot)
{
	bot.pos = bot.begin;
}


void botSavePath(Bot& bot, const Vector& begin, const Vector& end, const Vector& path[])
{
	int len = ArrayLen(bot.savedPaths);
	if(!len) {
		int tableNum = TABLE_NUM*TABLE_NUM;
		ArrayInit(bot.savedPaths, 0, tableNum);
	}

	PathEntry peNew;
	peNew.hash = vecHash(vecSub(end, begin));
	peNew.path = path;

	int idx = peNew.hash % len;
	bool saved = false;
	PathEntry pe;

	for(int i = idx; i < len-idx; i++)
	{
		pe = bot.savedPaths[i];

		if(pe.hash == peNew.hash)
			return;

		if(!pe.hash) {
			bot.savedPaths[i] = peNew;
			saved = true;
			break;
		}
	}
	if(!saved)
		bot.savedPaths[idx] = peNew;
}

bool botHasPath(const Bot& bot, const Vector& begin, const Vector& end, Vector& path[])
{
	int len = ArrayLen(bot.savedPaths);
	if(!len)
		return false;

	unsigned int hash = vecHash(vecSub(end, begin));
//	unsigned int hashRev = vecHash(vecSub(begin, end));

	PathEntry pe;
	int idx = hash % len;

	for(int i = idx; i < len-idx; i++)
	{
		pe = bot.savedPaths[i];
		if(pe.hash == hash) {
			path = pe.path;
			return true;
		}
/*		
		if(pe.hash == hashRev) {
			path = pe.path;
			pathReverse(path);
			return true;
		}
*/
	}
	return false;
}



// TODO: actual moving
void botMove(Bot& bot, const Vector& way, byte power)
{
	int distance = vecLength(way);
	Vector goal = vecAdd(bot.pos, way);
	int inc = sign(distance);

	logDebug( StrCat("DR:", vecToString(bot.pos), "+",vecToString(way), "=", vecToString(goal)) );

	while(!vecEq(bot.pos, goal)) {
		
		Wait(10000/power); // in my mind, I'm flying

		vecAddIp(bot.pos, vecMul(bot.dir, inc));
		logDebug(StrCat(">",vecToString(bot.pos)));
	}

}
void botRotate(Bot& bot, const Vector& dir, byte power) 
{
	int degree = vecAngle(bot.dir, dir);
	char inc = 10 * sign(degree);
	int r = degree % 10;

	if(!degree)
		return;

	logDebug( StrCat("RT:", vecToString(bot.dir), "->", vecToString(dir)) );

	if(r) 
	{
		Wait(r*1000/power);
		bot.dirDegree += r;
	}

	degree += bot.dirDegree;

	while(bot.dirDegree != degree)
	{
	 	Wait(10000/power); 
		bot.dirDegree += inc;
	}
	bot.dir = dir;
}
// ################

void botRun(Bot& bot, const Vector& path[])
{
	int dist;
	byte dir;
	Vector rel, norm;

	for(int i = 0; i < ArrayLen(path); i++) 
	{
		logDebug( StrCat("MV:", vecToString(bot.pos),"->", vecToString(path[i])) );

		rel = vecSub(path[i], bot.pos);
		norm = vecNorm(rel);
		if(!vecEq(bot.dir, norm)) 
			botRotate(bot, norm, 50);

		botMove(bot, rel, 50);
	}
}

#endif // BOT_INC