#ifndef MAP_INC
#define MAP_INC

#include "log.nxc"
#include "vector.nxc"


#define MAP_STRIDE  14
#define MAP_SIZE    MAP_STRIDE*MAP_STRIDE
#define MAP_CELL_CM 250 // 250 mm 

#define MAP_STRIDE_WB MAP_STRIDE-2
#define MAP_SIZE_WB MAP_STRIDE_WB*MAP_STRIDE_WB

#define MAP_FREE   ' '
#define MAP_WALL   '#'
#define MAP_START  'S'
#define MAP_BOT    'B'
#define MAP_ERR    '?'

static char map[MAP_SIZE];

char mapGetCellXY(int x, int y)
{
	y = -y;
	if(-1 < y && y < MAP_STRIDE  &&  -1 < x && x < MAP_STRIDE)
		return map[y * MAP_STRIDE + x];
	else {
		Vector v;
		v.x = x;
		v.y = y;
		logError("getCell", vecToString(v));
		return MAP_ERR;
	}
}

char mapGetCell(const Vector& v) 
{
	return mapGetCellXY(v.x, v.y);
}

void mapSetCellXY(int x, int y, char data)
{
	y = -y;
	if(-1 < y && y < MAP_STRIDE  &&  -1 < x && x < MAP_STRIDE)
		map[y * MAP_STRIDE + x] = data;
	else{
		Vector v;
		v.x = x;
		v.y = y;
		logError("setCell", vecToString(v));
	}
}

void mapSetCell(const Vector& v, char data)
{
	mapSetCellXY(v.x, v.y, data);
}

inline
bool mapIsObstacle(char c)
{
	return c == MAP_WALL;
}

inline
char mapGetCellCost(char c)
{
	// tables are costly
	if('0' < c && c < '9'+1)
		return 10;

	return 1;
}

#endif // MAP_INC