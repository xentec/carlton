#ifndef VECTOR_INC
#define VECTOR_INC


#define VEC_TYPE int

struct Vector 
{
	VEC_TYPE x,y;
};

static const Vector vecNULL = {0, 0};
static const Vector vecDIRS[] = { {0, -1}, {-1, 0}, {0, 1}, {1, 0} };

#define vecUP vecDIRS[0]
#define vecLEFT vecDIRS[1]
#define vecDOWN vecDIRS[2]
#define vecRIGHT vecDIRS[3]

inline
Vector vecNew(VEC_TYPE x, VEC_TYPE y)
{
	Vector v;
	v.x = x;
	v.y = y;
	return v;
}


string vecToString(const Vector& v)
{
	return StrCat(FormatVal("%d", v.x), ";", FormatVal("%d", v.y));
}

string vecToStringP(const Vector& v)
{
	return StrCat("{", vecToString(v),"}");
}

inline
int vecLengthSquared(const Vector& v)
{
	return v.x*v.x - v.y*v.y;
}

float vecLength(const Vector& v)
{
	if(v.x == 0)
		return v.y;
	if(v.y == 0)
		return v.x;

	return sqrt(vecLengthSquared(v)); // NXC
//	return sqrt(cast(float)vecLengthSquared(v));
}

inline
bool vecEq(const Vector& a, const Vector& b)
{
	return a.x == b.x && a.y == b.y;
}

int vecCmp(const Vector& a, const Vector& b)
{
	if(vecEq(a,b))
		return 0;
	
	return vecLengthSquared(a) > vecLengthSquared(b) ? -1 : 1;
}

inline
bool vecIsNull(const Vector& v)
{
	return vecEq(v, vecNULL);
}

Vector vecAdd(Vector v, const Vector& b)
{
	v.x += b.x;
	v.y += b.y;
	return v;
}

inline
void vecAddIp(Vector& v, const Vector& b)
{
	v.x += b.x;
	v.y += b.y;
}

Vector vecSub(Vector v, const Vector& b)
{
	v.x -= b.x;
	v.y -= b.y;
	return v;
}

inline
void vecSubIp(Vector& v, const Vector& b)
{
	v.x -= b.x;
	v.y -= b.y;
}

inline
Vector vecMul(Vector v, int b)
{
	v.x *= b;
	v.y *= b;
	return v;
}

inline
Vector vecDiv(Vector v, int b)
{
	v.x /= b;
	v.y /= b;
	return v;
}

int vecDot(const Vector& a, const Vector& b)
{
	return a.x*b.x+a.y*b.y;
}

int vecAngle(const Vector& a, const Vector& b)
{
	float deg = DEGREES_PER_RADIAN * acos(vecDot(a,b) / (vecLength(a)*vecLength(b)));
	deg = frac(deg) < 0.5 ? floor(deg) : ceil(deg);
	return trunc(deg);
}


#endif // VECTOR_INC